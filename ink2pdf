#!/usr/bin/env perl
use strict;
use warnings;

use v5.10.0;
use File::Spec;
use Getopt::Long;
use Pod::Usage;
use XML::LibXML;
use XML::LibXML::XPathContext;

# Inits
#<<<
my $opts = {};
GetOptions($opts,
    "background|b:s",
    "help|h",
    "insert|i:s@",
    "keep|k",
    "show-layers|l",
    "output|o:s",
    "tags|t:s",
    "verbose|v",
    "prefixes|x",
    ) or pod2usage(-verbose => 0,
                   -exitval => 22,  # 22 = EINVAL Invalid argument
                   -message => "*** Invalid option or bad syntax");
#>>>
pod2usage(
    -verbose => 2,
    -exitval => 0
) if $opts->{help};
pod2usage(
    -verbose => 0,
    -exitval => 2,                                    # 2 = ENOENT NO such file
    -message => "*** Missing Inkscape SVG filename"
) if !@ARGV;
my $SVGFILE    = $ARGV[0];
my $BGLAYER    = $opts->{background} || q{};
my $KEEP       = $opts->{keep};
my $SHOWLAYERS = $opts->{'show-layers'};
my @CTAGS      = split(',', $opts->{tags} || q{});
my $VERBOSE    = $opts->{verbose};
my $XMODE      = $opts->{prefixes};
die "*** Conditional tags may only be used with --prefixes (-x)\n"
    if @CTAGS && !$XMODE;

# Load file
my $xml = XML::LibXML->load_xml(location => $SVGFILE);
my $xpath = XML::LibXML::XPathContext->new($xml);
$xpath->registerNs("defNs", 'http://www.w3.org/2000/svg');

# Create related file names
my (undef, undef, $base) = File::Spec->splitpath($SVGFILE);
$base =~ s{\.svg$}{}i;
my $outfile = $opts->{output} || "$base.pdf";

# Get layer names
my @LAYERS = get_layers($xpath);
die "*** No layers in file $SVGFILE\n" unless @LAYERS;
if ($VERBOSE || $SHOWLAYERS) {
    say "Top-level layers:" if $VERBOSE;
    my $sp = $VERBOSE ? "  " : q{};
    print map {"$sp$_\n"} @LAYERS;
    exit 0 if $SHOWLAYERS;
}
if ($BGLAYER) {
    warn "--- Background layer not found: $BGLAYER\n"
        unless grep {$_ eq $BGLAYER} @LAYERS;
}

$XMODE
    ? do_by_prefix()
    : do_by_each();

exit 0;

#
#                           ------- o -------
#

sub do_by_each {
    say "Page Generation..." if $VERBOSE;

    my $pnum      = 0;
    my @pdf_files = ();
    foreach my $layer (@LAYERS) {
        next if $layer eq $BGLAYER;
        ++$pnum;

        # Create temp SVG with desired layers set
        my $tmpfile = sprintf("$base-%3.3d.svg", $pnum);
        say "  Temp SVG $tmpfile with layer '$layer' visible" if $VERBOSE;
        my $n = set_layers_visible($xpath, $layer, $BGLAYER);
        warn "--- No such layer: $layer\n" unless $n;
        $xml->toFile($tmpfile);

        # PDF generation
        my $pdffile = sprintf("$base-%3.3d.pdf", $pnum);
        push @pdf_files, $pdffile;
        generate_pdf($tmpfile, $pdffile);
        say "  Temp PDF $pdffile generated" if $VERBOSE;

        # Cleanup
        unlink $tmpfile;
    }

    # Unify PDF's
    if ($KEEP) {
        say "Individual PDF files will be kept (-k)" if $VERBOSE;
    }
    else {
        # ... unify ...
        say "  Unifying pages" if $VERBOSE;
        system("pdfunite " . join(" ", map {"'$_'"} @pdf_files) . " '" . $outfile . "'");
        say "  Cleanup" if $VERBOSE;
        unlink @pdf_files;
        say "Created $outfile" if $VERBOSE;
    }
}

sub do_by_prefix {
    my @prefixen = ();
    foreach my $layer (@LAYERS) {
        next unless $layer =~ m{^\s* ([pbc])
                                     (\* | L | R | [0-9\.\-]+)?
                                     (?:\(([a-z0-9\-\,]+))?
                                     \) }ix;
        push @prefixen, [lc $1, lc($2)||q{}, lc($3)||q{}, $layer];  # pbc, seq, ctag, layername
    }

#TEMP
    say "Prefixen:";
    foreach my $x (@prefixen) {
        say "  type: $x->[0]  pages: ".($x->[1]||q{--})."\ttags: ".($x->[2]||q{--})."\tlayer: '$x->[3]'";
    }
#ENDTEMP

    # Get content sequence numbers
    my @cseq = ();
    foreach my $x (@prefixen) {
        next if $x->[0] eq 'b';               # skip forced background layers
        my $seq = $x->[1];
        next unless $seq;                     # skip blank
        next unless $seq =~ m{^[0-9\.,]+$};   # can't be bg layer
        foreach my $sq (split(/,/, $seq)) {
            if ($sq !~ m{^\d+(\.\d*)?$}) {
                warn "--- Skip bad sequence number '$sq' in layer name '$x->[3]'\n";
                next;
            }
            push @cseq, $sq;
        }
    }

    # Build layer-sets list
    my @l2p  = ();
    my $pnum = 1;
    for my $sq (sort {($a+0.0) <=> ($b+0.0)} @cseq) {

        # Find all layers that match
        my $any = 0;
        foreach my $x (@prefixen) {
            if (seq_match($sq, $x->[1], $pnum)) {  # TODO: ctag match
                my $lname = $x->[3];
                if ($any) {
                    # Add to current page
                    push @{$l2p[-1]}, $lname;
                    print("    + $lname\n");    ### TEMP
                }
                else {
                    # Start new page
                    push @l2p, [$lname];
                    printf("%3.3d   %s\n", $pnum, $lname);    ### TEMP
                    $any = 1;
                }
            }
        }
        ++$pnum if $any;
    }
    die "*** No content in output\n" unless @l2p;

    # Generate output
    $pnum = 0;
    my @pdf_files = ();
    foreach my $lset (@l2p) {
        ++$pnum;

        # Create temp SVG with desired layers set
        my $tmpfile = sprintf("$base-%3.3d.svg", $pnum);
        say "  Temp SVG $tmpfile" if $VERBOSE;
        my $n = set_layers_visible($xpath, @$lset);
        warn "--- No matching layers for:\n" . (map {"\t$_\n"} @$lset) unless $n;
        $xml->toFile($tmpfile);

        # PDF generation
        my $pdffile = sprintf("$base-%3.3d.pdf", $pnum);
        push @pdf_files, $pdffile;
        generate_pdf($tmpfile, $pdffile);
        say "  Temp PDF $pdffile generated" if $VERBOSE;

        # Cleanup
        unlink $tmpfile;
    }

    # Unify PDF's
    if ($KEEP) {
        say "Individual PDF files will be kept (-k)" if $VERBOSE;
    }
    else {
        # ... unify ...
        say "  Unifying pages" if $VERBOSE;
        system("pdfunite " . join(" ", map {"'$_'"} @pdf_files) . " '" . $outfile . "'");
        say "  Cleanup" if $VERBOSE;
        unlink @pdf_files;
        say "Created $outfile" if $VERBOSE;
    }

}

# Does a given sequence match a sequence spec?
sub seq_match {
    my $sq = shift;
    my $spec = shift;
    my $pnum = shift;

    return 1 if $spec eq '*';
    return 1 if ($spec eq 'l') && ($pnum % 2) && ($pnum != 1);  # Left-side doesn't include p1
    return 1 if ($spec eq 'r') && !($pnum % 2);
    return 1 if $sq eq $spec;

    # TODO
    return 0;
}

# Create a one-page PDF
sub generate_pdf {
    my $inkfile = shift;
    my $outfile = shift;
    system("inkscape -z -A '$outfile' '$inkfile' 2>/dev/null");
}

# Get layer names (technically, called "labels")
sub get_layers {
    my $xpath  = shift;
    my @labels = ();
    foreach my $layer ($xpath->findnodes('/defNs:svg/defNs:g[@inkscape:groupmode="layer"]')) {
        my $label = $layer->{'inkscape:label'};
        push @labels, $label;
    }
    return @labels;
}

sub set_layers_visible {
    my $xpath = shift;
    my @toset = @_;

    my $numset = 0;
LAYER:
    foreach my $layer ($xpath->findnodes('/defNs:svg/defNs:g[@inkscape:groupmode="layer"]')) {
        my $label = $layer->{'inkscape:label'};
        foreach my $wantlabel (@toset) {
            if ($label eq $wantlabel) {
                $layer->{'style'} =~ s{\bdisplay:none\b}{display:inline};
                ++$numset;
                next LAYER;
            }
        }
        $layer->{'style'} =~ s{\bdisplay:inline\b}{display:none};
    }
    return $numset;
}

__END__

=head1 NAME

ink2pdf - Inkscape to Multi-Page PDF Document

=head1 SYNOPSIS

 ink2pdf [options] inkscape-file

 Options:
  -b  --background L   Use layer L as a backround layer (cannot use with -x)
  -h  --help           Usage summary
  -i  --insert N:file  Insert existing PDF file into document at page N; 
                         can use multiple times
  -k  --keep           Don't unite the pages into one PDF; keep each page 
                         as it's own numbered .pdf file
  -l  --show-layers    Show layer names and exit
  -o  --output PDFFILE Specify the output PDF file name; default is to 
                         replace the ".svg" suffix of the input file name 
                         with ".pdf"; if no ".svg" suffix then ".pdf" is 
                         appended.
  -t  --tags TAGS      Conditional tags in effect; separate tags with commas
  -x  --prefixes       Parse prefixes in layer names
  -v  --verbose        Verbose mode

=head1 DESCRIPTION

Generates a multi-page PDF document from your Inkscape document.
By default each layer becomes a page; use "page prefixes" in your
Inkscape document and the --prefixes (-x) option for better control.

=cut
